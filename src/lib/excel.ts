// Excel import/export utilities for Asset Inventory System
import * as XLSX from 'xlsx';
import { AssetWithInventoryStatus, EXCEL_IMPORT_COLUMNS, EXCEL_EXPORT_COLUMNS } from '@/types';
import { downloadFile } from '@/lib/utils';

// Import Excel file and convert to assets
export async function parseExcelFile(file: File): Promise<AssetWithInventoryStatus[]> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const data = e.target?.result;
        const workbook = XLSX.read(data, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];

        // Convert to JSON
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

        if (jsonData.length === 0) {
          reject(new Error('File Excel trống'));
          return;
        }

        // Get headers (first row)
        const headers = jsonData[0] as string[];
        const rows = jsonData.slice(1) as any[][];

        // Map headers to our column structure
        const columnMap = new Map<string, keyof AssetWithInventoryStatus>();
        EXCEL_IMPORT_COLUMNS.forEach(col => {
          const headerIndex = headers.findIndex(h =>
            h && h.toString().toLowerCase().trim() === col.header.toLowerCase().trim()
          );
          if (headerIndex !== -1) {
            columnMap.set(headerIndex.toString(), col.key);
          }
        });

        // Convert rows to assets
        const assets: AssetWithInventoryStatus[] = [];

        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          if (!row || row.length === 0) continue;

          const asset: any = {
            id: '', // Will be generated by database
            qr_generated: false,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            is_checked: false
          };

          // Map row data to asset properties
          columnMap.forEach((key, headerIndex) => {
            const cellValue = row[parseInt(headerIndex)];
            if (cellValue !== undefined && cellValue !== null && cellValue !== '') {
              asset[key] = cellValue.toString().trim();
            }
          });

          // Validate required fields
          if (!asset.asset_code || !asset.name) {
            console.warn(`Skipping row ${i + 2}: Missing required fields (asset_code or name)`);
            continue;
          }

          assets.push(asset);
        }

        if (assets.length === 0) {
          reject(new Error('Không tìm thấy dữ liệu hợp lệ trong file Excel'));
          return;
        }

        resolve(assets);
      } catch (error) {
        reject(new Error(`Lỗi đọc file Excel: ${error instanceof Error ? error.message : 'Unknown error'}`));
      }
    };

    reader.onerror = () => {
      reject(new Error('Lỗi đọc file'));
    };

    reader.readAsBinaryString(file);
  });
}

// Export assets to Excel
export function exportToExcel(assets: AssetWithInventoryStatus[], filename: string = 'assets'): void {
  try {
    console.log('Starting Excel export with', assets.length, 'assets');

    // Prepare data for export
    const exportData = assets.map(asset => {
      const row: any = {};

      EXCEL_EXPORT_COLUMNS.forEach(col => {
        let value = asset[col.key];

        // Format dates
        if (col.type === 'date' && value && typeof value === 'string') {
          try {
            value = new Date(value).toLocaleDateString('vi-VN');
          } catch {
            // Keep original value if date parsing fails
          }
        }

        // Format booleans
        if (col.type === 'boolean') {
          value = value ? 'Có' : 'Không';
        }

        row[col.header] = value || '';
      });

      return row;
    });

    console.log('Export data prepared:', exportData.length, 'rows');

    // Create workbook
    const ws = XLSX.utils.json_to_sheet(exportData);
    const wb = XLSX.utils.book_new();

    // Set column widths
    const colWidths = EXCEL_EXPORT_COLUMNS.map(col => ({ wch: col.width || 15 }));
    ws['!cols'] = colWidths;

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(wb, ws, 'Assets');

    // Generate Excel file
    const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });

    // Download file
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const fileName = `${filename}_${timestamp}.xlsx`;
    console.log('Preparing download for file:', fileName);

    downloadFile(
      new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }),
      fileName,
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    );

    console.log('Excel export completed successfully');
  } catch (error) {
    throw new Error(`Lỗi xuất file Excel: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

// Download Excel template
export function downloadTemplate(): void {
  try {
    // Create template data with sample row
    const templateData = [
      {
        'Mã tài sản': 'IT001',
        'Tên tài sản': 'Dell Laptop Inspiron 15',
        'Model': 'Inspiron 15 3000',
        'Serial': 'DL123456789',
        'Tech Code': 'TECH001',
        'Bộ phận': 'IT Department',
        'Tình trạng': 'Đang sử dụng',
        'Vị trí': 'Tầng 2 - Phòng IT',
        'Ghi chú': 'Laptop chính cho nhân viên IT'
      }
    ];

    // Create workbook
    const ws = XLSX.utils.json_to_sheet(templateData);
    const wb = XLSX.utils.book_new();

    // Set column widths
    const colWidths = EXCEL_IMPORT_COLUMNS.map(col => ({ wch: col.width || 20 }));
    ws['!cols'] = colWidths;

    // Add instructions
    const instructions = [
      'HƯỚNG DẪN IMPORT EXCEL:',
      '1. Giữ nguyên tên các cột header',
      '2. Mã tài sản và Tên tài sản là bắt buộc',
      '3. Xóa dòng hướng dẫn này trước khi import',
      '4. Thêm dữ liệu từ dòng thứ 2 trở đi',
      '5. Lưu file dưới định dạng .xlsx',
      '',
      'CÁC CỘT BẮT BUỘC:',
      '- Mã tài sản: Mã định danh duy nhất',
      '- Tên tài sản: Tên chi tiết của tài sản',
      '',
      'CÁC CỘT TÙY CHỌN:',
      '- Model, Serial, Tech Code, Bộ phận, Tình trạng, Vị trí, Ghi chú'
    ];

    // Add instructions to a separate sheet
    const instructionWs = XLSX.utils.aoa_to_sheet(instructions.map(line => [line]));
    XLSX.utils.book_append_sheet(wb, instructionWs, 'Hướng dẫn');

    // Add template sheet
    XLSX.utils.book_append_sheet(wb, ws, 'Template');

    // Generate and download
    const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    downloadFile(
      new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }),
      'asset_import_template.xlsx',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    );
  } catch (error) {
    throw new Error(`Lỗi tạo template: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

// Validate Excel file format
export function validateExcelFile(file: File): { valid: boolean; error?: string } {
  // Check file type
  if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
    return { valid: false, error: 'File phải có định dạng .xlsx hoặc .xls' };
  }

  // Check file size (max 10MB)
  if (file.size > 10 * 1024 * 1024) {
    return { valid: false, error: 'File không được vượt quá 10MB' };
  }

  return { valid: true };
}

// Parse and validate assets for bulk import with duplicate checking
export async function validateAssets(assets: AssetWithInventoryStatus[], existingAssets: AssetWithInventoryStatus[] = []): Promise<{
  valid: AssetWithInventoryStatus[];
  invalid: { row: number; asset: any; errors: string[] }[];
  duplicates: { row: number; asset: any; existingAsset: AssetWithInventoryStatus }[];
}> {
  const valid: AssetWithInventoryStatus[] = [];
  const invalid: { row: number; asset: any; errors: string[] }[] = [];
  const duplicates: { row: number; asset: any; existingAsset: AssetWithInventoryStatus }[] = [];

  // Create a map of existing asset codes for quick lookup
  const existingAssetCodes = new Map(
    existingAssets.map(asset => [asset.asset_code.toLowerCase().trim(), asset])
  );

  // Track asset codes within the import file to catch internal duplicates
  const importAssetCodes = new Set<string>();

  for (let i = 0; i < assets.length; i++) {
    const asset = assets[i];
    const errors: string[] = [];
    const rowNumber = i + 2; // +2 because Excel rows start at 1 and we skip header

    // Required field validation
    if (!asset.asset_code?.trim()) {
      errors.push('Mã tài sản không được để trống');
    }

    if (!asset.name?.trim()) {
      errors.push('Tên tài sản không được để trống');
    }

    // Check for duplicates only if asset_code exists
    if (asset.asset_code?.trim()) {
      const assetCodeLower = asset.asset_code.toLowerCase().trim();

      // Check for duplicates with existing assets in database
      const existingAsset = existingAssetCodes.get(assetCodeLower);
      if (existingAsset) {
        duplicates.push({ row: rowNumber, asset, existingAsset });
        continue; // Skip further validation for duplicates
      }

      // Check for duplicates within the import file
      if (importAssetCodes.has(assetCodeLower)) {
        errors.push('Mã tài sản trùng lặp trong file import');
      } else {
        importAssetCodes.add(assetCodeLower);
      }
    }

    if (errors.length > 0) {
      invalid.push({ row: rowNumber, asset, errors });
    } else {
      valid.push(asset);
    }
  }

  return { valid, invalid, duplicates };
}